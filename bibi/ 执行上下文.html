<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!-- 
    执行上下文，预处理的过程

    1.代码的分类（位置）
      全局代码
      函数（局部）代码
    2.全局执行上下文
      在执行全局代码前，将window确定为全局执行上下文
      对全局数据进行预处理
       var 定义的全局变量===>undefined,添加为window的属性
       function 声明的函数==>赋值（fun）添加为window的方法
       this===》赋值（window）
    开始执行全局代码
    3.函数执行上下文
    在调用函数之前，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟的，存在于栈中）
    对局部数据进行预处理：
      行参变量===》赋值（实参）==》添加为执行上下文属性
      arguments==>赋值（实参列表）添加为执行上下文属性
      var定义的局部变量==》undefined 添加为执行上下文的属性
      function 声明的函数==》赋值（fun）添加为执行上下文的方法
      this===>赋值（调用函数对象）
    开始执行函数整体代码

  全局执行上下文和函数执行上下文
   -->
  <script>
    // console.log(a1);//undefined
    // console.log(a2);//undefined
    // console.log(this);//window
    // var a1=3;
    // var a2=4
    // // 函数执行上下文
    // function fn(a1){
    //   console.log(a1);//0
    //   console.log(a2);//window.a2//4
    //   console.log(a3);//undefined
    //   var a3=55
    //   ffn()//ffn
    //   console.log(this);//window
    //   console.log(arguments);//0,4545//伪数组
    //   function ffn(){
    //     console.log("ffn");
    //   }
    // }
    // fn(0,4545)

    // 执行上下文栈，后进先出，栈内存中
    // console.log("global begin:" + i);//undefined
    // var i = 1
    // foo(1)
    // function foo(i) {
    //   if (i == 4) {
    //     return;
    //   }
    //   console.log("foo() begin :" + i);//1,2,3,
    //   foo(i + 1)//递归调用，在函数内部调用自己
    //   console.log("foo() end :" + i);//3,2,1
    // }
    // console.log("global end:" + i);//1

    // 先执行变量提升，在执行函数提升，所以var a在前面，function a在后面，后面的覆盖前面
    function a() { }
    var a;
    console.log(typeof a);//function

    // 
    if (!(b in window)) {
      var b = 1
    }
    console.log(b);//undefined

    var c = 1//声明并赋值，window.c=1
    function c(c) {
      console.log(c);
      var c = 3
    }
    console.log(typeof c);//number
    console.log(this);
    c(2)//报错
  </script>
</body>

</html>